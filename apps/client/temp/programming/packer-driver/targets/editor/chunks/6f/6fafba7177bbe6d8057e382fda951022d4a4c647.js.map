{"version":3,"sources":["file:///D:/CocosProject/cocos-nodejs-io-game-start-demo-master/apps/client/assets/Scripts/Base/StateMachine.ts"],"names":["_decorator","Component","FsmParamTypeEnum","ccclass","getInitParamsTrigger","type","Trigger","value","getInitParamsNumber","Number","StateMachine","_currentState","params","Map","stateMachines","animationComponent","getParams","paramName","has","get","setParams","run","resetTrigger","console","error","currentState","newState"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAASA,MAAAA,U,OAAAA,U;AAAuBC,MAAAA,S,OAAAA,S;;AAEvBC,MAAAA,gB,iBAAAA,gB;;;;;;;;;OACH;AAAEC,QAAAA;AAAF,O,GAAcH,U,GAKoB;;AAMxC;sCACaI,oB,GAAuB,MAAM;AACxC,eAAO;AACLC,UAAAA,IAAI,EAAE;AAAA;AAAA,oDAAiBC,OADlB;AAELC,UAAAA,KAAK,EAAE;AAFF,SAAP;AAID,O;;qCACYC,mB,GAAsB,MAAM;AACvC,eAAO;AACLH,UAAAA,IAAI,EAAE;AAAA;AAAA,oDAAiBI,MADlB;AAELF,UAAAA,KAAK,EAAE;AAFF,SAAP;AAID,O;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;;yBAE8BG,Y,WAD7BP,OAAO,CAAC,cAAD,C,gBAAR,MAC8BO,YAD9B,SACmDT,SADnD,CAC6D;AAAA;AAAA;;AAC3D;AACF;AACA;AAH6D,eAInDU,aAJmD,GAIV,IAJU;AAAA,eAK3DC,MAL2D,GAKvB,IAAIC,GAAJ,EALuB;AAKb;AALa,eAM3DC,aAN2D,GAML,IAAID,GAAJ,EANK;AAMK;AANL,eAO3DE,kBAP2D;AAAA,eAQ3DV,IAR2D;AAAA;;AAQtC;AAErBW,QAAAA,SAAS,CAACC,SAAD,EAAoB;AAC3B,cAAI,KAAKL,MAAL,CAAYM,GAAZ,CAAgBD,SAAhB,CAAJ,EAAgC;AAC9B,mBAAO,KAAKL,MAAL,CAAYO,GAAZ,CAAgBF,SAAhB,EAA2BV,KAAlC;AACD;AACF;;AAEDa,QAAAA,SAAS,CAACH,SAAD,EAAoBV,KAApB,EAA4C;AACnD,cAAI,KAAKK,MAAL,CAAYM,GAAZ,CAAgBD,SAAhB,CAAJ,EAAgC;AAC9B;AACA,iBAAKL,MAAL,CAAYO,GAAZ,CAAgBF,SAAhB,EAA2BV,KAA3B,GAAmCA,KAAnC,CAF8B,CAG9B;;AACA,iBAAKc,GAAL,GAJ8B,CAK9B;AACA;;AACA,iBAAKC,YAAL;AACD,WARD,MAQO;AACLC,YAAAA,OAAO,CAACC,KAAR,CAAe,MAAK,KAAKnB,IAAK,SAAQY,SAAU,EAAhD;AACA;AACD;AAEF;;AAEe,YAAZQ,YAAY,GAAG;AACjB,iBAAO,KAAKd,aAAZ;AACD;;AAEe,YAAZc,YAAY,CAACC,QAAD,EAAW;AACzB,cAAI,CAACA,QAAL,EAAe;AACb;AACD;;AACD,eAAKf,aAAL,GAAqBe,QAArB;;AACA,eAAKf,aAAL,CAAmBU,GAAnB;AACD;AAED;AACF;AACA;;;AACEC,QAAAA,YAAY,GAAG;AACb,eAAK,MAAM,GAAGf,KAAH,CAAX,IAAwB,KAAKK,MAA7B,EAAqC;AACnC,gBAAIL,KAAK,CAACF,IAAN,KAAe;AAAA;AAAA,sDAAiBC,OAApC,EAA6C;AAC3CC,cAAAA,KAAK,CAACA,KAAN,GAAc,KAAd;AACD;AACF;AACF;AAED;AACF;AACA;;;AAzD6D,O","sourcesContent":["import { _decorator, Animation, Component } from \"cc\";\n\nimport { FsmParamTypeEnum } from \"../Enum\";\nconst { ccclass } = _decorator;\nimport State from \"./State\";\nimport SubStateMachine from \"./SubStateMachine\";\nimport { EntityTypeEnum } from \"../Common\";\n\ntype ParamsValueType = boolean | number;//联合类型用作状态的转换\n\nexport interface IParamsValue {\n  type: FsmParamTypeEnum;\n  value: ParamsValueType;\n}\n//定义了translate 的形态\nexport const getInitParamsTrigger = () => {\n  return {\n    type: FsmParamTypeEnum.Trigger,\n    value: false,\n  };\n};\nexport const getInitParamsNumber = () => {\n  return {\n    type: FsmParamTypeEnum.Number,\n    value: 0,\n  };\n};\n/***\n* 流动图\n* 1.entity的state或者direction改变触发setter\n* 2.setter里触发fsm的setParams方法\n * 3.setParams执行run方法（run方法由子类重写）\n * 4.run方法会更改currentState，然后触发currentState的setter\n* 5-1.如果currentState是子状态机，继续执行他的run方法，run方法又会设置子状态机的currentState，触发子状态run方法\n* 5-2.如果是子状态，run方法就是播放动画\n*/\n//混合树 状态机 子状态机 translate   状态机与状态机之间存在转换 状态机与子状态机也存在转换\n/***\n * 有限状态机基类 状态机之间的总处理中心 根据状态机的名字调用对应的状态机\n */\n@ccclass(\"StateMachine\")\nexport default abstract class StateMachine extends Component {\n  /***\n     * 当前状态 \n     */\n  private _currentState: State | SubStateMachine = null;\n  params: Map<string, IParamsValue> = new Map();//用于存储转换条件\n  stateMachines: Map<string, SubStateMachine | State> = new Map();//用于存储状态机和对应方向的子状态机\n  animationComponent: Animation;\n  type: EntityTypeEnum;//是谁的状态机在做\n\n  getParams(paramName: string) {\n    if (this.params.has(paramName)) {\n      return this.params.get(paramName).value;\n    }\n  }\n\n  setParams(paramName: string, value: ParamsValueType) {\n    if (this.params.has(paramName)) {\n      //设置状态机之间的translate的值 根据名字和类型调整状态机与状态机之间的转换\n      this.params.get(paramName).value = value;\n      //执行状态机\n      this.run();\n      //状态机之间如果是双向的 应该是前往下一个状态之后(执行完当前状态机所对应的动画)返回到上一个状态机\n      //即使是初始状态start 与idle 之间也是无限触发状态才对 只是每次播放完idle动画 回到start状态后 都会再次回到idle状态机中\n      this.resetTrigger();\n    } else {\n      console.error(`状态机${this.type}中不存在参数${paramName}`);\n      return;\n    }\n\n  }\n\n  get currentState() {\n    return this._currentState;\n  }\n\n  set currentState(newState) {\n    if (!newState) {\n      return;\n    }\n    this._currentState = newState;\n    this._currentState.run();\n  }\n\n  /***\n   * 清空所有trigger\n   */\n  resetTrigger() {\n    for (const [, value] of this.params) {\n      if (value.type === FsmParamTypeEnum.Trigger) {\n        value.value = false;\n      }\n    }\n  }\n\n  /***\n   * 由子类重写，方法目标是根据当前状态和参数修改currentState\n   */\n  abstract init(...args: any[]): void;\n  abstract run(): void;\n}\n"]}